// Prisma Client Generator
generator client {
  provider = "prisma-client-js"
  engineType = "binary"
}
 
// Database Connection (url is in prisma.config.ts for Prisma 7)
datasource db {
  provider = "postgresql"
}
<<<<<<< HEAD



// This is the central Prisma schema for the entire modular ITSM system.
// Each model and field is commented with its purpose and relations.
// All team members must use this schema as the contract for data shape.

=======
 
>>>>>>> 8a48d8c5dcba3cd0a45517314db77a09aca7963c
// ------------------------------------
// ENUMS
// ------------------------------------
 
enum TicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}
 
enum AssetStatus {
  AVAILABLE
  ALLOCATED
  IN_REPAIR
  RETIRED
}
 
enum RequestStatus {
  PENDING
  MANAGER_APPROVED
  ADMIN_APPROVED
  REJECTED
  ALLOCATED
}
 
enum ApprovalStatus {
  APPROVED
  REJECTED
}
 
// ------------------------------------
// MODELS
// ------------------------------------
 
model Role {
  id    Int    @id @default(autoincrement())
  name  String @unique
  users User[]
}
 
model User {
  id       Int    @id @default(autoincrement())
  name     String
  email    String @unique
  password String
  roleId   Int
 
  role Role @relation(fields: [roleId], references: [id])
 
  ticketsCreated  Ticket[]
  ticketsAssigned Ticket[] @relation("AssignedTickets")
 
  assetRequests   AssetRequest[]
  approvals       Approval[] @relation("UserApprovals")
 
  ticketComments   TicketComment[]
  notifications    Notification[]
  assetAllocations AssetAllocation[]
 
  createdAt DateTime @default(now())
}
 
model Ticket {
  id           Int          @id @default(autoincrement())
  title        String
  description  String
  status       TicketStatus @default(OPEN)
  priority     String
  createdById  Int
  assignedToId Int?
 
  createdBy  User  @relation(fields: [createdById], references: [id])
  assignedTo User? @relation("AssignedTickets", fields: [assignedToId], references: [id])
 
  comments TicketComment[]
 
  slaHours  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
 
model TicketComment {
  id       Int    @id @default(autoincrement())
  message  String
  ticketId Int
  userId   Int
 
  ticket Ticket @relation(fields: [ticketId], references: [id])
  user   User   @relation(fields: [userId], references: [id])
 
  createdAt DateTime @default(now())
}
 
model Notification {
  id      Int     @id @default(autoincrement())
  message String
  userId  Int
  read    Boolean @default(false)
 
  user User @relation(fields: [userId], references: [id])
 
  createdAt DateTime @default(now())
}
 
model Asset {
  id       Int         @id @default(autoincrement())
  name     String
  serialNo String      @unique
  status   AssetStatus @default(AVAILABLE)
 
  allocations   AssetAllocation[]
  assetRequests AssetRequest[]
 
  createdAt DateTime @default(now())
}
 
model AssetAllocation {
  id          Int       @id @default(autoincrement())
  assetId     Int
  userId      Int
  allocatedAt DateTime  @default(now())
  returnedAt  DateTime?
 
  asset Asset @relation(fields: [assetId], references: [id])
  user  User  @relation(fields: [userId], references: [id])
}
 
model AssetRequest {
  id      Int           @id @default(autoincrement())
  userId  Int
  assetId Int
  reason  String        // âœ… Added reason field
  status  RequestStatus @default(PENDING)
 
  user      User       @relation(fields: [userId], references: [id])
  asset     Asset      @relation(fields: [assetId], references: [id])
  approvals Approval[]
 
  createdAt DateTime @default(now())
}
 
model Approval {
  id           Int            @id @default(autoincrement())
  requestId    Int
  approvedById Int
  status       ApprovalStatus
 
  request    AssetRequest @relation(fields: [requestId], references: [id])
  approvedBy User         @relation("UserApprovals", fields: [approvedById], references: [id])
 
  createdAt DateTime @default(now())
}

 